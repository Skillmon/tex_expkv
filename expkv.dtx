% \iffalse meta-comment
%
% File: expkv.dtx Copyright (C) 2020 Jonathan P. Spratte
%
% This work  may be  distributed and/or  modified under  the conditions  of the
% LaTeX Project Public License (LPPL),  either version 1.3c  of this license or
% (at your option) any later version.  The latest version of this license is in
% the file:
%
%   http://www.latex-project.org/lppl.txt
%
% ------------------------------------------------------------------------------
%
%<*driver>^^A>>=
\def\nameofplainTeX{plain}
\ifx\fmtname\nameofplainTeX\else
  \expandafter\begingroup
\fi
\input l3docstrip.tex
\askforoverwritefalse
\preamble

--------------------------------------------------------------
expkv -- an expandable key=val implementation
E-mail: jspratte@yahoo.de
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt
--------------------------------------------------------------

Copyright (C) 2020 Jonathan P. Spratte

This  work may be  distributed and/or  modified under  the conditions  of the
LaTeX Project Public License (LPPL),  either version 1.3c  of this license or
(at your option) any later version.  The latest version of this license is in
the file:

  http://www.latex-project.org/lppl.txt

This work is "maintained" (as per LPPL maintenance status) by
  Jonathan P. Spratte.

This work consists of the file  expkv.dtx
and the derived files           expkv.pdf
                                expkv.sty
                                expkv.tex

\endpreamble
% stop docstrip adding \endinput
\postamble
\endpostamble
\generate{\file{expkv.sty}{\from{expkv.dtx}{pkg}}}
\generate{\file{expkv.tex}{\from{expkv.dtx}{tex}}}
\ifx\fmtname\nameofplainTeX
  \expandafter\endbatchfile
\else
  \expandafter\endgroup
\fi
%
\ProvidesFile{expkv.dtx}
  [\csname expkv@date\endcsname\ an expandable key=val implementation]
\PassOptionsToPackage{full}{textcomp}
\documentclass{l3doc}
\RequirePackage[oldstylenums]{kpfonts}
\RequirePackage{listings}
\RequirePackage{booktabs}
\RequirePackage{siunitx}
\RequirePackage{xcolor}
\RequirePackage{caption}
\RequirePackage{microtype}
\lstset
  {
    ,flexiblecolumns=false
    ,basewidth=.52em
    ,gobble=2
    ,basicstyle=\itshape
    ,morekeywords={\ekvdef,\ekvdefNoVal,\ekvset}
    ,morecomment=[l]\%
    ,commentstyle=\color[gray]{0.4}
    ^^A,literate=*{<key>}{\key}{4}{<set>}{\set}{4}
  }
\RequirePackage{randtext}
\IfFileExists{expkv.tex}{\input{expkv.tex}}{}
\let\metaORIG\meta
\protected\def\meta #1{\texttt{\metaORIG{#1}}}
\renewcommand*\thefootnote{\fnsymbol{footnote}}
\colorlet{expkvred}{red!65!black}
\colorlet{expkvgrey}{black!75}
\makeatletter
\newcommand*\expkv
  {^^A
    \texorpdfstring
      {^^A
        \begingroup
        \bfseries
        {\color{expkvgrey}e\kern-.05em x\kern-.05em}^^A
        \lower.493ex\hbox{{\color{expkvgrey}P}\kern-.1em{\color{expkvred}k}}^^A
        \kern-.18em{\color{expkvred}v}^^A
        \endgroup
      }
      {expkv}^^A
  }
\newcommand\kv{\meta{key}=\meta{value}}
\newcommand\key{\meta{key}}
\newcommand\val{\meta{value}}
\newcommand\set{\meta{set}}
\hypersetup{linkcolor=red!80!black,urlcolor=purple!80!black}
\makeatother
\begin{document}
  \title
    {^^A
      \texorpdfstring
        {^^A
          \huge
          \href{https://github.com/Skillmon/tex_expkv}
            {\expkv}^^A
          \\[\medskipamount]
          \Large an expandable \kv\ implementation^^A
        }{expkv - an expandable <key>=<value> implementation}^^A
    }
  \date{\csname ekvDate\endcsname\space v\csname ekvVersion\endcsname}
  \author{Jonathan P. Spratte\thanks{\protect\randomize{jspratte@yahoo.de}}}
  \DocInput{expkv.dtx}
\end{document}
%</driver>^^A=<<
% \fi
%
% \maketitle
%
% \begin{abstract}
% \noindent\parfillskip=0pt
% \expkv\ provides a small interface for \kv\ parsing. The parsing macro is
% fully expandable, the \meta{code} of your keys might be not. \expkv\ is pretty
% fast, but not the fastest available \kv\ solution (\pkg{keyval} for instance
% is thrice as fast, but not expandable and it might strip braces it shouldn't
% have stripped).
% \end{abstract}
%
% \tableofcontents
%
% \begin{documentation}^^A>>=
%
% \section{Documentation}
%
% \expkv\ provides an expandable \kv\ parser. The \kv\ pairs should be given as
% a comma separated list and the separator between a \key\ and the associated
% \val\ should be an equal sign. Both, the commas and the equal signs, might be
% of category 12 (other) or 13 (active). To support this is necessary as for
% example \pkg{babel} turns characters active for some languages, for instance
% the equal sign is turned active for Turkish.
%
% \expkv\ is usable as generic code or as a \LaTeX\ package. To use it, just
% use one of:
% \begin{lstlisting}
% \usepackage{expkv} % LaTeX
% \input expkv       % plainTeX
% \end{lstlisting}
% The \LaTeX\ package doesn't do more than \file{expkv.tex}, except calling
% |\ProvidesPackage| and setting things up such that \file{expkv.tex} will use
% |\ProvidesFile|.
%
% \subsection{Setting up Keys}\label{sec:define}
%
% Keys in \expkv\ (as in almost all other \kv\ implementations) belong to a
% \emph{set} such that different sets can contain keys of the same name. Unlike
% many other implementations \expkv\ doesn't provide means to set a default
% value, instead we have keys that take values and keys that don't (the latter
% are called |NoVal| keys by \expkv), but both can have the same name (on the
% user level).
%
% The following macros are available to define new keys. Those macros containing
% ``|def|'' in their name can be prefixed by anything allowed to prefix |\def|,
% prefixes allowed for |\let| can prefix those with ``|let|'' in their name,
% accordingly. Neither \set\ nor \key\ are allowed to be empty for new keys and
% must not contain a |\par| or tokens that expand to it. They must be legal
% inside of |\csname ...\endcsname|.
%
% \begin{function}{\ekvdef}
%   \begin{syntax}
%     \cs{ekvdef}\marg{set}\marg{key}\marg{code}
%   \end{syntax}
%   Defines a \key\ taking a value in a \set\ to expand to \meta{code}. In
%   \meta{code} you can use |#1| to refer to the given value.
% \end{function}
%
% \begin{function}{\ekvdefNoVal}
%   \begin{syntax}
%     \cs{ekvdefNoVal}\marg{set}\marg{key}\marg{code}
%   \end{syntax}
%   Defines a no value taking \key\ in a \set\ to expand to \meta{code}.
% \end{function}
%
% \begin{function}{\ekvlet}
%   \begin{syntax}
%     \cs{ekvlet}\marg{set}\marg{key}\meta{cs}
%   \end{syntax}
%   Let the value taking \key\ in \set\ to \meta{cs}, there are no checks on
%   \meta{cs} enforced.
% \end{function}
%
% \begin{function}{\ekvletNoVal}
%   \begin{syntax}
%     \cs{ekvletNoVal}\marg{set}\marg{key}\meta{cs}
%   \end{syntax}
%   Let the no value taking \key\ in \set\ to \meta{cs}, it is not checked
%   whether \meta{cs} exists or that it takes no parameter.
% \end{function}
%
% \begin{function}{\ekvletkv}
%   \begin{syntax}
%     \cs{ekvletkv}\marg{set}\marg{key}\marg{set2}\marg{key2}
%   \end{syntax}
%   Let the \key\ in \set\ to \meta{key2} in \meta{set2}, it is not checked
%   whether that second key exists.
% \end{function}
%
% \begin{function}{\ekvletkvNoVal}
%   \begin{syntax}
%     \cs{ekvletkvNoVal}\marg{set}\marg{key}\marg{set2}\marg{key2}
%   \end{syntax}
%   Let the \key\ in \set\ to \meta{key2} in \meta{set2}, it is not checked
%   whether that second key exists.
% \end{function}
%
% \subsection{Parsing Keys}
%
% \begin{function}{\ekvset}
%   \begin{syntax}
%     \cs{ekvset}\marg{set}\{\kv,\kv,\ldots\}
%   \end{syntax}
%   Splits \kv\ pairs on commas. From both \key\ and \val\ up to one space is
%   stripped from both ends, if then only a braced group remains the braces are
%   stripped as well. So |\ekvset{foo}{bar=baz}| and
%   |\ekvset{foo}{ {bar}= {baz} }| will both do
%   \texttt{\cs{\meta{foobarcode}}\{baz\}}, so you can hide commas, equal signs
%   and spaces at the ends of either \key\ or \val\ by putting braces around
%   them. If you omit the equal sign the code of the key created with the
%   |NoVal| variants described in \autoref{sec:define} will be executed. If \kv\
%   contains more than a single unhidden equal sign, it will be split at the
%   first one and the others are considered part of the value.
%   |\ekvset| should be nestable.
% \end{function}
%
% \subsection{Example}
%
% Say we have a macro for which we want to create a \kv\ interface. The macro
% has a parameter, which is stored in the dimension \cs{ourdim} having a default
% value from its initialization. Now we want to be able to change that dimension
% with the |width| key to some specified value. For that we'd do
% \begin{lstlisting}
% \newdimen\ourdim
% \ourdim=150pt
% \protected\ekvdef{our}{width}{\ourdim=#1\relax}
% \end{lstlisting}
% as you can see, we use the set |our| here. We want the key to behave different
% if no value is specified. In that case the key should not use the its initial
% value, but be smart and determine the available space from \cs{hsize}, so we
% also define
% \begin{lstlisting}
% \protected\ekvdefNoVal{our}{width}{\ourdim=.9\hsize}
% \end{lstlisting}
% Now we set up our macro to use this \kv\ interface
% \begin{lstlisting}
% \protected\def\ourmacro#1{\begingroup\ekvset{our}{#1}\the\ourdim\endgroup}
% \end{lstlisting}
% Finally we can use our macro like in the following\\
% \begin{minipage}{6cm}
% \begin{lstlisting}
% \ourmacro{}\par
% \ourmacro{width}\par
% \ourmacro{width=5pt}\par
% \end{lstlisting}
% \end{minipage}^^A
% \begin{minipage}{\dimexpr\linewidth-6cm\relax}
%   \newdimen\ourdim\ourdim=150pt
%   \protected\ekvdef{our}{width}{\ourdim=#1\relax}^^A
%   \protected\ekvdefNoVal{our}{width}{\ourdim=.9\hsize}^^A
%   \protected\def\ourmacro#1^^A
%     {\begingroup\ekvset{our}{#1}\the\ourdim\endgroup}^^A
%   \ourmacro{}\par
%   \ourmacro{width}\par
%   \ourmacro{width=5pt}\par
% \end{minipage}
%
% \subsection{Miscellaneous}
%
% \subsubsection{Other Macros}
%
% \expkv\ provides some other macros which might be of interest.
%
% \begin{function}{\ekvifdefined,\ekvifNoValdefined}
%   \begin{syntax}
%     \cs{ekvifdefined}\marg{set}\marg{key}\marg{true}\marg{false}
%     \cs{ekvifNoValdefined}\marg{set}\marg{key}\marg{true}\marg{false}
%   \end{syntax}
%   These two macros test whether there is a \key\ in \set. It is false if
%   either a hash table entry doesn't exist for that key or its meaning is
%   |\relax|.
% \end{function}
%
% \begin{function}{\ekvbreak,\ekvbreakPreSneak,\ekvbreakPostSneak}
%   \begin{syntax}
%     \cs{ekvbreak}\marg{after}
%   \end{syntax}
%   Gobbles the remainder of the current |\ekvset| macro and its argument list
%   and reinserts \meta{after}. So this can be used to break out of |\ekvset|.
%   The first variant will also gobble anything that has been sneaked out using
%   |\ekvsneak| or |\ekvsneakPre|, while |\ekvbreakPreSneak| will put
%   \meta{after} before anything that has been smuggled and |\ekvbreakPostSneak|
%   will put \meta{after} after the stuff that has been sneaked out.
% \end{function}
%
% \begin{function}{\ekvsneak,\ekvsneakPre}
%   \begin{syntax}
%     \cs{ekvsneak}\marg{after}
%   \end{syntax}
%   Puts \meta{after} after the effects of |\ekvset|. The first variant will put
%   \meta{after} after any other tokens which might have been sneaked before,
%   while |\ekvsneakPre| will put \meta{after} before other smuggled stuff.
%   This reads and reinserts the remainder of the current |\ekvset| macro and
%   its argument list to do its job.
% \end{function}
%
% \bigskip
%
% \begin{function}{\ekv@name}
%   \begin{syntax}
%     \cs{ekv@name}\marg{set}\marg{key}
%   \end{syntax}
%   The names of the macros that correspond to a key in a set are build with
%   this macro. The default definition is
%   \texttt{\csname ekv@name\endcsname{\set}{\key}}, for |NoVal| keys an
%   additional |N| gets appended irrespective of this macro's definition, so
%   their name is \texttt{\csname ekv@name\endcsname{\set}{\key}N}.
% \end{function}
%
% \subsubsection{Bugs}
%
% You can either report bugs via mail (see the first page), or directly on
% github if you own an account there:
% \url{https://github.com/Skillmon/tex_expkv}
%
% \subsubsection{Comparisons}
%
% Comparisons of speed are done with a very simple test key and the help of the
% \pkg{l3benchmark} package. The key and its usage should be equivalent to
% \begin{lstlisting}
% \protected\ekvdef{test}{height}{\def\myheight{#1}}
% \ekvset{test}{ height = 6 }
% \end{lstlisting}
% and only the usage of the key, not its definition, is benchmarked. As far as I
% know \expkv\ is the only fully expandable \kv\ parser. I tried to compare
% \expkv\ to every \kv\ package listed on
% \href{https://ctan.org/topic/keyval}{CTAN}, however, one might notice that
% some of those are missing from this list. That's because I didn't get the
% others to work due to bugs, or because they just provide wrappers around other
% packages in this list. For the impatient, the essence of these comparisons
% regarding speed and buggy behaviour is contained in \autoref{tab:comp}.
%
% \paragraph{\pkg{keyval}} is around three times faster and has a comparable
% feature set just a slightly different way how it handles keys without values.
% That might be considered a drawback, as it limits the versatility, but also as
% an advantage, as it might reduce doubled code. Keep in mind that as soon as
% someone loads \pkg{xkeyval} the performance of \pkg{keyval} gets replaced by
% \pkg{xkeyval}'s.
%
% Also \pkg{keyval} has a bug, which unfortunately can't really be resolved
% without breaking backwards compatibility for \emph{many} documents, namely it
% strips braces from the argument before stripping spaces if the argument isn't
% surrounded by spaces, also it might strip more than one set of braces. Hence
% all of the following are equivalent in their outcome, though the last two
% lines should result in something different than the first two:
% \begin{lstlisting}[belowskip=0pt]
% \setkeys{foo}{bar=baz}
% \setkeys{foo}{bar= {baz}}
% \setkeys{foo}{bar={ baz}}
% \setkeys{foo}{bar={{baz}}}
% \end{lstlisting}
%
% \paragraph{\pkg{xkeyval}} is almost ten times slower, but it provides more
% functionality, e.g., it has choice keys, boolean keys, and so on. It contains
% the same bug as \pkg{keyval} as it has to be compatible with it by design (it
% replaces \pkg{keyval}'s frontend), but also adds even more cases in which
% braces are stripped that shouldn't be stripped, worsening the situation.
%
% \paragraph{\pkg{ltxkeys}} is about 200 times slower -- which is funny, because
% it aims to be ``[\ldots] faster than these earlier packages [referring to
% \pkg{keyval} and \pkg{xkeyval}].'' Since it aims to have a bigger feature set
% than \pkg{xkeyval}, it most definitely also has a bigger feature set than
% \expkv. Also, it can't parse |\long| input, so as soon as your values contain
% a |\par|, it'll throw errors. Furthermore, \pkg{ltxkeys} doesn't strip outer
% braces at all by design, which, imho, is a weird design choice. In addition
% \pkg{ltxkeys} loads \pkg{catoptions} which is known to introduce bugs (e.g.,
% see \url{https://tex.stackexchange.com/questions/461783}).
%
% \paragraph{\pkg{l3keys}} is about three times slower, but has an, imho, great
% interface to define keys. It strips \emph{all} outer spaces, even if somehow
% multiple spaces ended up on either end. It offers more features, but is pretty
% much bound to \pkg{expl3} code. Whether that's a drawback is up to you.
%
% \paragraph{\pkg{pgfkeys}} is about one and a half times slower, but has an
% \emph{enormous} feature set. It has the same or a very similar bug
% \pkg{keyval} has.
%
% \paragraph{\pkg{kvsetkeys} with \pkg{kvdefinekeys}} is about two times slower,
% but it works even if commas and equals have category codes different from 12.
% Else the features of the keys are equal to those of \pkg{keyval}, the parser
% has more features, though.
%
% \paragraph{\pkg{options}} is a bit faster than \expkv\ (about
% \SI{20}{\percent}) and has a much bigger feature set. Unfortunately it also
% suffers from the premature unbracing bug \pkg{keyval} has.
%
% \paragraph{\pkg{simplekv}} is hard to compare because I don't speak French (so
% I don't understand the documentation) and from what I can see, there is no
% direct way to define the equivalent test key. Nevertheless, I tested the
% closest possible equivalent of my test key while siding for \pkg{simplekv}'s
% design not forcing something into it it doesn't seem to be designed for. It is
% almost four times slower and has hard to predict behaviour regarding brace and
% space stripping, similar to \pkg{keyval}. The tested definition was:
% \begin{lstlisting}[belowskip=0pt]
% \usepackage{simplekv}
% \setKVdefault[simplekv]{height={ abc}}                     % key setup 
% \setKV[simplekv]{ height = 6 }                             % benchmarked
% \end{lstlisting}
%
% \paragraph{\pkg{yax}} is twelve times slower. It has a pretty strange syntax,
% imho, and again a direct equivalent is hard to define. It has the premature
% unbracing bug, too. Also somehow loading \pkg{yax} broke \pkg{options} for me.
% The tested definition was:
% \begin{lstlisting}[belowskip=0pt]
% \usepackage{yax}
% \defactiveparameter yax {\storevalue\myheight yax:height } % key setup
% \setparameterlist{yax}{ height = 6 }                       % benchmarked
% \end{lstlisting}
%
% \begin{table}
%   \centering
%   \newcommand*\yes{\textcolor{red!80!black}  {yes}}^^A
%   \newcommand*\no {\textcolor{green!80!black}{no}}^^A
%   \caption[Comparison of \kv\ packages]
%     {^^A
%       Comparison of \kv\ packages. Operations are the required operations to
%       evaluate one key, measured with the \pkg{l3benchmark} package (and a
%       target time of \SI{30}{\second}), which only returns the three most
%       significant digits. The column ``Category Fragile'' lists whether the
%       parsing breaks with active commas or equal signs.^^A
%       \label{tab:comp}^^A
%     }
%   \begin{tabular}{lS[table-format=4.1]ccc}
%     \toprule
%     Package & {Operations} & Brace-Bug & Category Fragile & Date \\
%     \midrule
%     \pkg{keyval}    &   15.2 & \yes    & \yes             & 2014-10-28 \\
%     \pkg{options}   &   38.0 & \yes    & \yes             & 2015-03-01 \\
%     \expkv          &   45.3 & \no     & \no              & 2020-01-14 \\
%     \pkg{pgfkeys}   &   69.1 & \yes    & \yes             & 2019-12-21 \\
%     \pkg{kvsetkeys} &   96.0 & \no     & \no              & 2019-12-15 \\
%     \pkg{l3keys}    &  141   & \no     & \no              & 2019-11-07 \\
%     \pkg{simplekv}  &  178   & \yes    & \yes             & 2017-08-08 \\
%     \pkg{xkeyval}   &  443   & \yes    & \yes             & 2014-12-03 \\
%     \pkg{yax}       &  547   & \yes    & \yes             & 2010-01-22 \\
%     \pkg{ltxkeys}   & 9260   & \no     & \no              & 2012-11-17 \\
%     \bottomrule
%   \end{tabular}
% \end{table}
%
% \subsection{Error Messages}
%
% \expkv\ should only send messages in case of errors, there are no warnings and
% no info messages. In this subsection those errors are listed.
%
% \subsubsection{Load Time}
%
% \file{expkv.tex} checks whether \eTeX\ is available. If it isn't, an error
% will be thrown using |\errmessage|:
% \begin{lstlisting}
% ! expkv Error: e-TeX required.
% \end{lstlisting}
%
% \subsubsection{Defining Keys}
%
% If you get any error from \expkv\ while you're trying to define a key, the
% definition will be aborted and gobbled.
%
% If you try to define a key with an empty set name you'll get:
% \begin{lstlisting}
% ! expkv Error: empty set name not allowed.
% \end{lstlisting}
%
% Similarly, if you try to define a key with an empty key name:
% \begin{lstlisting}
% ! expkv Error: empty key name not allowed.
% \end{lstlisting}
%
% Both of these messages are done in a way that doesn't throw additional errors
% due to |\global|, |\long|, etc., not being used correctly if you prefixed one
% of the defining macros.
%
% \subsubsection{Using Keys}
%
% This subsubsection contains the errors thrown during |\ekvset|. The errors are
% thrown in an expandable manner by providing an undefined macro. In the
% following messages \lstinline|<key>| gets replaced with the problematic key's
% name, and \lstinline|<set>| with the corresponding set. If any errors during
% \kv\ handling are encountered, the entry in the comma separated list will be
% omitted after the error is thrown and the next \kv\ pair will be parsed.
%
% If you're using an undefined key you'll get:
% \begin{lstlisting}
% ! Undefined control sequence.
% <argument> \! expkv Error:
%                            unknown key (`<key>', set `<set>').
% \end{lstlisting}
%
% If you're using a key for which only a normal version and no |NoVal| version
% is defined, but don't provide a value, you'll get:
% \begin{lstlisting}
% ! Undefined control sequence.
% <argument> \! expkv Error:
%                            value required (`<key>', set `<set>').
% \end{lstlisting}
%
% If you're using a key for which only a |NoVal| version and no normal version
% is defined, but provide a value, you'll get:
% \begin{lstlisting}
% ! Undefined control sequence.
% <argument> \! expkv Error:
%                            value forbidden (`<key>', set `<set>').
% \end{lstlisting}
%
% \end{documentation}^^A=<<
%
% \begin{implementation}^^A>>=
%
% \clearpage
%
% \section{Implementation}^^A>>=
%^^A the LaTeX package >>=
% First we set up the \LaTeX\ package. That one doesn't really do much except
% |\input|ting the generic code and identifying itself as a package.
%    \begin{macrocode}
%<*pkg>
\def\ekv@tmp
  {%
    \ProvidesFile{expkv.tex}%
      [%
        \ekvDate\space v\ekvVersion\space
        an expandable key=val implementation%
      ]%
  }
\input{expkv.tex}
\ProvidesPackage{expkv}%
  [\ekvDate\space v\ekvVersion\space an expandable key=val implementation]
%</pkg>
%    \end{macrocode}
%^^A=<<
%^^A main file >>=
% The rest of this implementation will be the generic code.
%    \begin{macrocode}
%<*tex>
%    \end{macrocode}
%
% Check whether \eTeX\ is available -- \expkv\ requires \eTeX.
%    \begin{macrocode}
\begingroup\expandafter\expandafter\expandafter\endgroup
\expandafter\ifx\csname numexpr\endcsname\relax
  \errmessage{expkv requires e-TeX}
  \expandafter\endinput
\fi
%    \end{macrocode}
%
% We make sure that it's only input once:
%    \begin{macrocode}
\expandafter\ifx\csname ekvVersion\endcsname\relax
\else
  \expandafter\endinput
\fi
%    \end{macrocode}
% We're on our first input, so lets store the version and date in a macro.
%    \begin{macrocode}
\def\ekvVersion{0.2}
\def\ekvDate{2020-01-14}
%    \end{macrocode}
%
% If the \LaTeX\ format is loaded we want to be a good file and report back who
% we are, for this the package will have defined |\ekv@tmp| to use
% |\ProvidesFile|, else this will expand to a |\relax| and do no harm.
%    \begin{macrocode}
\csname ekv@tmp\endcsname
%    \end{macrocode}
%
% Store the category code of |@| to later be able to reset it and change it to
% 11.
%    \begin{macrocode}
\expandafter\chardef\csname ekv@tmp\endcsname=\catcode`\@
\catcode`\@=11
%    \end{macrocode}
% |\ekv@tmp| might later be reused to gobble any prefixes which might be
% provided to |\ekvdef| and similar in case the names are invalid, we just
% temporarily use it here as means to store the current category code of |@| to
% restore it at the end of the file, we never care for the actual definition of
% it.
%
% Since branching tests are often more versatile than |\if...\else...\fi|
% constructs, we define helpers that are branching pretty fast. Also here are
% some other utility functions that just grab some tokens. The ones that are
% also contained in \LaTeX\ don't use the |ekv| prefix.
%    \begin{macrocode}
\long\def\ekv@gobbletostop#1\ekv@stop{}
\long\def\@firstofone#1{#1}
\long\def\@firstoftwo#1#2{#1}
\long\def\@secondoftwo#1#2{#2}
\long\def\ekv@fi@gobble\fi\@firstofone#1{\fi}
\long\def\ekv@fi@secondoftwo\fi\@firstoftwo#1#2{\fi#2}
%    \end{macrocode}
% As you can see |\ekv@gobbletostop| uses a special marker |\ekv@stop|. The
% package will use three such markers, the one you've seen already, |\ekv@mark|
% and |\ekv@nil|. Contrarily to how for instance \pkg{expl3} does things, we
% don't define them, as we don't need them to have an actual meaning. This has
% the advantage that if they somehow get expanded -- which should never happen
% if things work out -- they'll throw an error directly.
%
% We can test for a lot of things building on an if-empty test, so lets define a
% really fast one. Since some tests might have reversed logic (true if something
% is not empty) we also set up macros for the reversed branches.
%    \begin{macrocode}
\long\def\ekv@ifempty#1%
  {%
    \ekv@ifempty@\ekv@ifempty@A#1\ekv@ifempty@B\ekv@ifempty@true
      \ekv@ifempty@A\ekv@ifempty@B\@secondoftwo
  }
\long\def\ekv@ifempty@#1\ekv@ifempty@A\ekv@ifempty@B{}
\long\def\ekv@ifempty@true\ekv@ifempty@A\ekv@ifempty@B\@secondoftwo#1#2{#1}
\long\def\ekv@ifempty@false\ekv@ifempty@A\ekv@ifempty@B\@firstoftwo#1#2{#2}
\long\def\ekv@ifempty@true@F\ekv@ifempty@A\ekv@ifempty@B\@firstofone#1{}
%    \end{macrocode}
%
% The obvious test that can be based on an if-empty is if-blank, meaning a test
% checking whether the argument is empty or consists only of spaces. Our version
% here will be tweaked a bit, as we want to check this, but with one leading
% |\ekv@mark| token that is to be ignored.
%    \begin{macrocode}
\long\def\ekv@ifblankF#1%
  {%
    \ekv@ifblank@#1\ekv@nil\ekv@ifempty@B\ekv@ifempty@true@F
      \ekv@ifempty@A\ekv@ifempty@B\@firstofone
  }
\long\def\ekv@ifblank@\ekv@mark#1{\ekv@ifempty@\ekv@ifempty@A}
%    \end{macrocode}
%
% We'll need to check whether something is defined quite frequently, so why not
% define a macro that does this. The following test is expandable, slower than
% the typical expandable test for undefined control sequences, but faster for
% defined ones. Since we want to be as fast as possible for correct input, this
% is to be preferred.
%    \begin{macrocode}
\def\ekv@ifdefined#1%
  {%
    \expandafter
    \ifx\csname\ifcsname #1\endcsname #1\else relax\fi\endcsname\relax
      \ekv@fi@secondoftwo
    \fi
    \@firstoftwo
  }
%    \end{macrocode}
% Since we can save some time if we only have to create the control sequence
% once when we know beforehand how we want to use it, we build some other macros
% for those cases (which we'll have quite often, once per key usage).
%    \begin{macrocode}
\def\ekv@ifdefined@pair#1#2%
  {%
    \expandafter\ekv@ifdefined@pair@
      \csname
        \ifcsname\ekv@name{#1}{#2}\endcsname\ekv@name{#1}{#2}\else relax\fi
      \endcsname
  }
\def\ekv@ifdefined@pair@#1%
  {%
    \ifx#1\relax
      \ekv@fi@secondoftwo
    \fi
    \@firstoftwo
    {\ekv@parse@pair@#1\ekv@mark}%
  }
\def\ekv@ifdefined@key#1#2%
  {%
    \expandafter\ekv@ifdefined@key@
      \csname
        \ifcsname \ekv@name{#1}{#2}N\endcsname \ekv@name{#1}{#2}N\else relax\fi
      \endcsname
  }
\def\ekv@ifdefined@key@#1%
  {%
    \ifx#1\relax
      \ekv@fi@secondoftwo
    \fi
    \@firstoftwo#1%
  }
%    \end{macrocode}
%
% The keys will all follow the same naming scheme, so we define it here.
% \begin{macro}{\ekv@name}
%    \begin{macrocode}
\def\ekv@name#1#2{ekv#1(#2)}
%    \end{macrocode}
% \end{macro}
% We place some restrictions on the allowed names, though, namely sets and
% keys are not allowed to be empty -- blanks are fine (meaning \mbox{set-
% or} key-names consisting of spaces).
%    \begin{macrocode}
\protected\long\def\ekv@checkvalid#1#2#3%
  {%
    \ekv@ifempty{#1}%
      {%
        \def\ekv@tmp{}%
        \errmessage{expkv Error: empty set name not allowed}%
      }%
      {%
        \ekv@ifempty{#2}%
          {%
            \def\ekv@tmp{}%
            \errmessage{expkv Error: empty key name not allowed}%
          }%
          {#3}%
      }%
  }
%    \end{macrocode}
% And provide user-level macros to test whether a key is defined.
% \begin{macro}{\ekvifdefined,\ekvifNoValdefined}
%    \begin{macrocode}
\def\ekvifdefined#1#2{\ekv@ifdefined{\ekv@name{#1}{#2}}}
\def\ekvifNoValdefined#1#2{\ekv@ifdefined{\ekv@name{#1}{#2}N}}
%    \end{macrocode}
% \end{macro}
%
% Set up the key defining macros |\ekvdef| etc.
% \begin{macro}{\ekvdef}
%    \begin{macrocode}
\protected\long\def\ekvdef#1#2#3%
  {%
    \ekv@checkvalid{#1}{#2}%
      {\expandafter\def\csname\ekv@name{#1}{#2}\endcsname##1{#3}}%
  }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ekvdefNoVal}
%    \begin{macrocode}
\protected\long\def\ekvdefNoVal#1#2#3%
  {%
    \ekv@checkvalid{#1}{#2}%
      {\expandafter\def\csname\ekv@name{#1}{#2}N\endcsname{#3}}%
  }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ekvlet}
%    \begin{macrocode}
\protected\def\ekvlet#1#2%
  {%
    \ekv@checkvalid{#1}{#2}%
      {\expandafter\let\csname\ekv@name{#1}{#2}\endcsname}%
  }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ekvletNoVal}
%    \begin{macrocode}
\protected\def\ekvletNoVal#1#2%
  {%
    \ekv@checkvalid{#1}{#2}%
      {\expandafter\let\csname\ekv@name{#1}{#2}N\endcsname}%
  }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ekvletkv}
%    \begin{macrocode}
\protected\def\ekvletkv#1#2#3#4%
  {%
    \ekv@checkvalid{#1}{#2}%
      {%
        \expandafter\let\csname\ekv@name{#1}{#2}\expandafter\endcsname
        \csname\ekv@name{#1}{#2}\endcsname
      }%
  }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ekvletkvNoVal}
%    \begin{macrocode}
\protected\def\ekvletkvNoVal#1#2#3#4%
  {%
    \ekv@checkvalid{#1}{#2}%
      {%
        \expandafter\let\csname\ekv@name{#1}{#2}N\expandafter\endcsname
        \csname\ekv@name{#1}{#2}N\endcsname
      }%
  }
%    \end{macrocode}
% \end{macro}
%
% And set up |\ekvset|, which should not be affected by active commas and equal
% signs. The equal signs are a bit harder to cope with and we'll do that later,
% but replacing the active commas with commas of category other can be done
% beforehand. That's why we define |\ekvset| here with a temporary meaning just
% to set up the things with two different category codes. |#1| will be a
% \texttt{,\textsubscript{13}} and |#2| will be a \texttt{=\textsubscript{13}}.
% \begin{macro}{\ekvset}
%    \begin{macrocode}
\def\ekvset#1#2{%
\endgroup
\long\def\ekvset##1##2%
  {%
    \ekv@parse{##1}\ekv@mark##2#1\ekv@stop#1{}%
  }
%    \end{macrocode}
% \end{macro}
% |\ekv@parse| will split the \kv\ list at active commas. Then it has to check
% whether there were unprotected other commas and resplit there.
%    \begin{macrocode}
\long\def\ekv@parse##1##2#1%
  {%
%    \end{macrocode}
% Test whether we're at the end, if so invoke |\ekv@endparse|,
%    \begin{macrocode}
    \ekv@ifstop##2\ekv@endparse\ekv@mark\ekv@stop
%    \end{macrocode}
% else go on with other commas,
%    \begin{macrocode}
    \ekv@splitcomma@other{##1}##2,\ekv@stop,%
%    \end{macrocode}
% and get the next active comma delimited \kv\ pair.
%    \begin{macrocode}
    \ekv@parse{##1}\ekv@mark
  }
%    \end{macrocode}
% |\ekv@endparse| is a hungry little macro. It will eat everything that remains
% of |\ekv@parse| and unbrace the sneaked stuff.
%    \begin{macrocode}
\long\def\ekv@endparse
    \ekv@mark\ekv@stop\ekv@splitcomma@other##1,\ekv@stop,\ekv@parse##2\ekv@mark
    ##3%
  {##3}
%    \end{macrocode}
% The macro |\ekv@splitcomma@other| is guaranteed to get only single \kv\ pairs.
% So here we need to split at equal signs. If there is no equal sign, we need to
% test whether we're done and if not this is a |NoVal| key.
%    \begin{macrocode}
\long\def\ekv@splitcomma@other##1##2,%
  {%
    \ekv@ifblank@##2\ekv@nil\ekv@ifempty@B\ekv@ifempty@true@F
      \ekv@ifempty@A\ekv@ifempty@B\@firstofone
      {%
        \ekv@ifhaseq@other##2=\ekv@ifempty@B\ekv@ifempty@false
          \ekv@ifempty@A\ekv@ifempty@B\@firstoftwo
          {\ekv@spliteq@other{##1}##2\ekv@stop}%
          {%
            \ekv@ifhaseq@active##2#2\ekv@ifempty@B\ekv@ifempty@false
              \ekv@ifempty@A\ekv@ifempty@B\@firstoftwo
              {\ekv@spliteq@active{##1}##2\ekv@stop}%
              {%
                \ekv@ifstop##2\ekv@endsplitcomma\ekv@mark\ekv@stop
                \ekv@strip{##2}\ekv@parse@key{##1}%
              }%
          }%
      }%
    \ekv@splitcomma@other{##1}\ekv@mark%
  }
%    \end{macrocode}
% |\ekv@spliteq@other| might not be the correct break point, there might be an
% active equal sign in the currently parsed key-name. If so, we have to resplit.
%    \begin{macrocode}
\long\def\ekv@spliteq@other##1##2=%
  {%
    \ekv@ifhaseq@active##2#2\ekv@ifempty@B\ekv@ifempty@false
      \ekv@ifempty@A\ekv@ifempty@B\@firstoftwo
      {\ekv@spliteq@active{##1}##2=}%
      {\ekv@strip{##2}\ekv@parse@pair{##1}}%
  }
%    \end{macrocode}
% We need to handle the active equal signs.
%    \begin{macrocode}
\long\def\ekv@spliteq@active##1##2#2%
  {%
    \ekv@strip{##2}\ekv@parse@pair{##1}%
  }
%    \end{macrocode}
% And we have to set up the testing macros for our equal signs and
% |\ekv@endsplitcomma|.
%    \begin{macrocode}
\long\def\ekv@ifhaseq@other\ekv@mark##1={\ekv@ifempty@\ekv@ifempty@A}
\long\def\ekv@ifhaseq@active\ekv@mark##1#2{\ekv@ifempty@\ekv@ifempty@A}
\long\def\ekv@endsplitcomma
    \ekv@mark\ekv@stop\ekv@strip##1\ekv@parse@key##2%
    \ekv@splitcomma@other##3\ekv@mark
  {}
%    \end{macrocode}
% One last thing we need to do with the changed category codes is to provide
  % macros that just smuggle stuff after |\ekvset|'s effects.
% \begin{macro}{\ekvsneak,\ekvsneakPre}
%    \begin{macrocode}
\long\def\ekvsneak##1##2\ekv@stop#1##3%
  {%
    ##2\ekv@stop#1{##3##1}%
  }
\long\def\ekvsneakPre##1##2\ekv@stop#1##3%
  {%
    ##2\ekv@stop#1{##1##3}%
  }
%    \end{macrocode}
% \end{macro}
%
% Finally really setting things up with |\ekvset|'s temporary meaning:
%    \begin{macrocode}
}
\begingroup
\catcode`\,=13
\catcode`\==13
\ekvset,=
%    \end{macrocode}
%
% The |\ekv@ifstop| test works similar to our if-empty test, but instead of
% using tokens which are used nowhere else (|\ekv@ifempty@A| and
% |\ekv@ifempty@B|) we use |\ekv@mark| and |\ekv@stop|.
%    \begin{macrocode}
\long\def\ekv@ifstop#1\ekv@mark\ekv@stop{}
%    \end{macrocode}
%
% |\ekv@parse@pair| needs to split the argument at the |=| sign and check
% whether the key is defined.
%    \begin{macrocode}
\long\def\ekv@parse@pair#1#2%
  {%
    \ekv@ifdefined@pair{#2}{#1}%
      {%
        \ekv@ifdefined{\ekv@name{#2}{#1}N}%
          \ekv@err@noarg
          \ekv@err@unknown
          {#2}{#1}%
        \ekv@gobbletostop
      }%
  }
\long\def\ekv@parse@pair@#1#2\ekv@stop
  {%
    \ekv@strip{#2}#1%
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\long\def\ekv@parse@key#1#2%
  {%
    \ekv@ifdefined@key{#2}{#1}%
      {%
        \ekv@ifdefined{\ekv@name{#2}{#1}}%
          \ekv@err@reqval
          \ekv@err@unknown
          {#2}{#1}%
      }%
  }
%    \end{macrocode}
%
% Provide macros that can completely stop the parsing of |\ekvset|, who knows
% what it'll be useful for.
% \begin{macro}{\ekvbreak,\ekvbreakPreSneak,\ekvbreakPostSneak}
%    \begin{macrocode}
\long\def\ekvbreak#1#2\ekv@stop,#3{#1}
\long\def\ekvbreakPreSneak #1#2\ekv@stop,#3{#1#3}
\long\def\ekvbreakPostSneak#1#2\ekv@stop,#3{#3#1}
%    \end{macrocode}
% \end{macro}
%
% Since |\ekvset| is fully expandable as long as the code of the keys is (which
% is unlikely) we want to somehow throw expandable errors, in our case via
% undefined control sequences.
%    \begin{macrocode}
\begingroup
\edef\ekv@err
  {%
    \endgroup
    \unexpanded{\long\def\ekv@err}##1%
      {%
        \unexpanded{\expandafter\ekv@err@\@firstofone}%
        {\expandafter\noexpand\csname ! expkv Error:\endcsname ##1.}%
        \unexpanded{\ekv@stop}%
      }%
  }
\ekv@err
\def\ekv@err@{\expandafter\ekv@gobbletostop}
%    \end{macrocode}
% Now we can use |\ekv@err| to set up some error messages so that we can later
% use those instead of the full strings.
%    \begin{macrocode}
\long\def\ekv@err@unknown#1#2{\ekv@err{unknown key (`#2', set `#1')}}
\long\def\ekv@err@noarg  #1#2{\ekv@err{value forbidden (`#2', set `#1')}}
\long\def\ekv@err@reqval #1#2{\ekv@err{value required (`#2', set `#1')}}
%    \end{macrocode}
%
% Finally we borrow some ideas of \pkg{expl3}'s \pkg{l3tl} to strip spaces
% from keys and values. This |\ekv@strip| also strips one level of outer braces
% \emph{after} stripping spaces, so an input of | {abc} | becomes |abc| after
% stripping. It should be used with |#1| prefixed by |\ekv@mark|.
%    \begin{macrocode}
\def\ekv@strip#1%
  {%
    \long\def\ekv@strip##1%
      {%
        \ekv@strip@a
          ##1%
          \ekv@nil
          \ekv@mark#1%
          #1\ekv@nil{}%
        \ekv@stop
      }%
    \long\def\ekv@strip@a##1\ekv@mark#1##2\ekv@nil##3%
      {%
        \ekv@strip@b##3##1##2\ekv@nil
      }%
    \long\def\ekv@strip@b##1#1\ekv@nil
      {%
        \ekv@strip@c##1\ekv@nil
      }%
    \long\def\ekv@strip@c\ekv@mark##1\ekv@nil##2\ekv@stop##3%
      {%
        ##3{##1}%
      }%
  }
\ekv@strip{ }
%    \end{macrocode}
%
% Now everything that's left is to reset the category code of |@|.
%    \begin{macrocode}
\catcode`\@=\ekv@tmp
%    \end{macrocode}
%
%
%    \begin{macrocode}
%</tex>
%    \end{macrocode}
%^^A=<<
%
%^^A=<<
%
% \end{implementation}^^A=<<
%
\endinput
%
^^A vim: ft=tex fdm=marker fmr=>>=,=<<
